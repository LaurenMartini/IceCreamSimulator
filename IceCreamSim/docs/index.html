<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  /*h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }*/
  /*h1 {
    color: rgb(108, 208, 224);
  }*/
  div.padded {  
      padding-top: 0px;  
      padding-right: 100px;  
      padding-bottom: 0.25in;  
      padding-left: 100px;  
    }
    span {
      color: rgb(150, 222, 233);
      font-weight: bolder;
        text-shadow: 0.5px 0.5px rgb(199, 238, 241);
    }
    h1 {
      font-family: 'Ubuntu', Sans-Serif;
      color: rgb(45, 188, 210);
        text-shadow: 2px 2px rgb(199, 238, 241);
  }

  h2 {
    font-family: 'Ubuntu', Sans-Serif;
    color: rgb(108, 208, 224);
        text-shadow: 1px 1px rgb(199, 238, 241);
  }

  p {
    font-family: 'Open Sans', Sans-Serif;
  }

  figcaption {
    font-family: 'Open Sans', Sans-Serif;
  }

  td {
    font-family: 'Open Sans', Sans-Serif;
    font-size: 15px;
  }  
</style>
<title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Ubuntu:700" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2017</h1>
<h1 align="middle">Project 4: Cloth Simulator</h1>
<h2 align="middle">Natalie Khamphanh, CS184-aet</h2>

<br><br>

<div align="middle">
  <img src="images/part5_texture_cloth_cover.png" width="50%"/>
</div>

<div>

<h2 align="middle">Overview</h2>

<p>In this project, I implemented a cloth simulator that would simulate the interactions of cloth with real objects. I created a system of masses and springs in order to build the cloth model that would be simulated on. I then simulated the movement of cloth, specifically how cloth would move when falling while pinned at a point. This included a damping factor that would control how the cloth would move and rest with different damping conditions. I extended this simulation of cloth interactions to include cloth colliding with objects and itself. Lastly, I implemented shaders such as the Blinn-Phong model, diffuse, reflections, textures, and bump mapping. After working on this project, I can now see why simulations in programs such as Maya can be very glitchy.</p>

<h2 align="middle">Part I: Masses and Springs</h2>
<div>
  <p>Before I am able to simulate anything, a cloth must be created by a system of springs and point masses. In this part, I implemented the function <span>buildGrid</span>, which builds a grid of masses and springs in order to create a cloth. I create an evenly spaced grid of masses by looping through the given variables <span>num_height_points</span> and <span>num_width_points</span>. Within these loops, I scale <span>x</span>, <span>y</span>, and <span>z</span> depending on whether the orientation of the cloth is horizontal or vertical. I also check to see if certain point masses are going to be pinned and then create a <span>Point Mass</span> with the coordinates that were calculated and a boolean that accounts for whether it is pinned or not.</p>
  <p>I then create the springs by again looping over <span>num_height_points</span> and <span>num_width_points</span> and basically create a spring for each type of constraint for each point mass. For structural springs, one spring is made between a point mass and the point mass to the left of it and another spring is made between a point mass and the point mass above it. For shearing, I make sure that there exists a point mass that is to the diagonal upper left and diagonal upper right of the current point mass and create a spring between the current point mass and one of the other two if the point masses exist. For the bending constraint, I must check if there is a point mass that is two to the left of the current point mass and two above the current point mass and create the corresponding springs.</p>
  <p>After implementing this correctly, a wireframe representing the cloth is created like the one shown below.</p>
</div>
<div align="middle">
  <img src="images/part1_pinned2.png" width="480px"/>
</div>
<br>
<div align="middle">
  <p>Shown below are images of the cloth wireframe with certain constraints indicated in the captions</p>
    <table style="width:80%">
      <tr>
        <td>
          <img src="images/part1_woShearing.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">Without shearing constraints.</figcaption>
        </td>
        <td>
          <img src="images/part1_onlyShearing.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">Only shearing constraints.</figcaption>
        </td>
      </tr>
    </table>
    <img src="images/part1_wAll.png" width="480px"/>
    <figcaption align="middle" style="font-weight: bold">With structural, shearing, and bending constraints.</figcaption>
  </div>
</div>

<br><br>
<h2 align="middle">Part II: Simulation via Numerical Integration</h2>
<div>
  <p>This part is where the simulation of how cloth moves. By the end of this part, the cloth will move as one would think it would when pinned.</p>
  <p>I implement the <span>simulate</span> function by first computing the total external force that is acting on each point mass by accumulating the sum of each value in <span>external_accelerations</span> and then multiplying this sum by the mass. I then set each point mass's forces to this external force. The next step is to apply a spring correction force to each spring in which the spring type is currently enabled. I take the <span>PointMass</span> on the ends of the spring and calculate the force applied to them using Hooke's law.</p>

  <p align="middle"><pre align="middle" style="font-size: 16px;">Hooke's Law: F<sub>s</sub> = k<sub>s</sub> (||p<sub>a</sub> - p<sub>b</sub>|| - l)</pre></p>

  <p>After finding the force, I either add or subtract this force to the point mass's force vectors depending on the direction I calculated. This only calculates the forces applied for the current timestep, but we would like to calculate the change in position for each point mass as well.</p>
  <p>In order to implement that, Verlet integration is used to compute the new positions.</p>

  <p align="middle"><pre align="middle" style="font-size: 16px;">Verlet Integration: x<sub>t+dt</sub> = x<sub>t</sub> + (1 - d) * (x<sub>t</sub> - x<sub>t-dt</sub>) + a<sub>t</sub> * dt<sup>2</sup></pre></p>

  <p>This formula also simulates damping in order to account for the loss of energy due to friction. At this point, the pinned cloth should fall like you think it would.</p>

  <div align="middle">
    <img src="images/glitchyClothPart2.gif" width="480px"/>
    <figcaption align="middle">Yeah, this is totally what's supposed to happen.</figcaption>
    <figcaption>(For PDF readers, this gif is basically a really glitchy unpinned cloth that falls down infinitely.)</figcaption>
  </div>

  <p>The issue shown in the above gif was a result of many issues, such as something happening with the pinning check in Part 1. There were also problems with normalizing and not normalizing vectors in the part when calculating the force applied by Hooke's law.</p>

  <p>In order to control weird deformations, deformation constrains were implemented. The springs were constrained such that the length of the spring was no longer than 10% greater than the <span>rest_length</span> at the end of a time step. For each spring that is not pinned, and the distance between the ends of the spring is greater than the <span>rest_length</span> of the spring, I create a correction vector which consists of the the difference of the distance and the constraint length multiplied by the direction. If both point masses are not pinned, this correction vector is scaled by 0.5. Depending on whether or not one point mass is pinned, I then add or subtract the correction vector to the position of the point masses.</p>

  <div align="middle">
    <img src="images/part2_normalParams.png" width="480px"/>
    <figcaption>After implementing everything correctly, this is how my cloth looks like pinned and in its resting state.</figcaption>
  </div>

</div>
<div align="middle">
    <p>Below, I play around with the spring constant, density, and damping parameters.</p>

    <table style="width:80%">
      <tr>
        <td>
          <img src="images/part2_ks10.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">ks = 10</figcaption>
        </td>
        <td>
          <img src="images/part2_ks10000.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">ks = 10,000</figcaption>
        </td>
      </tr>
    </table>
    <p>When the spring constant is low, the cloth appears kind of heavy. It looks as if the cloth is being stretched from the bottom of the cloth being pulled. There is a dip in the top middle of the dress that doesn't fold in. I want to say that it reminds me of rayon dresses, but I'm not quite sure if that's the right material. on the otherhand, when the spring constant is high, the cloth appears more flat and stiff. The dip in the middle is also different from the other cloth since it appears to have a fold.</p>

    <br><br>
    <table style="width:80%">
      <tr>
        <td>
          <img src="images/part2_density1.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">density = 1</figcaption>
        </td>
        <td>
          <img src="images/part2_density1000.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">density = 1,000</figcaption>
        </td>
      </tr>
    </table>
    <p>When density is low, the cloth appears stiffer and there aren't many folds in the dip (in this case, there is only 1 fold). The dip also doesn't appear to be that low. When density is much higher, the cloth looks similar to when the spring constant is low. It has the appearance of being stretched. The dip in the cloth is lower compared to when density is low and also has several folds.</p>

    <br><br>
    <table style="width:80%">
      <tr>
        <td>
          <img src="images/part2_damp0.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">damping = 0.0</figcaption>
        </td>
        <td>
          <img src="images/part2_damp1-stillFalling.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">damping = 1.0</figcaption>
        </td>
      </tr>
    </table>
    <p>When damping is set to 0, the cloth will fall but then will keep swaying around. When swaying backwards, the scene looks super windy. It's super flowy and has a ton of folds. When damping is set to 1, the cloth takes much longer to fall and appears flat.</p>
</div>

<br><br>
<h2 align="middle">Part III: Handling Collisions with Other Objects</h2>
<div>
  <div>
    <p>In order to handle the cloth colliding with other objects, then I must check whether or not a point mass is inside of the object. I first handle collisions with spheres by implementing the <span>Sphere::collide</span> function. I check if the point mass intersects with the sphere by calculating the distance between the point mass's position and the origin and comparing the difference to the length of the sphere's radius. If the difference is less than the radius, then I calculate the tangent point by adding the direction vector scaled by the length of the radius to the origin of the sphere. Then, the correction vector is calculated by subtracting the tangent point and the point mass's last position and then multiplying it by <span>(1.0 - friction)</span>. I set the new position of the point mass to the correction vector added to the last position. The result shown is a cloth that rests nicely on the sphere.</p>
    <div align="middle">
      <img src="images/part3_sphere_ks5000.png" width="480px"/>
      <figcaption align="middle" style="font-weight: bold">ks = 5000</figcaption>
    </div>

    <table style="width=80%">
      <tr>
        <td>
          <img src="images/part3_sphere_ks500.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">ks = 500</figcaption>
        </td>
        <td>
          <img src="images/part3_sphere_ks50000.png" width="480px"/>
          <figcaption align="middle" style="font-weight: bold">ks = 50000</figcaption>
        </td>
      </tr>
    </table>
    <p>The images shown above show a cloth draped on the sphere at their final resting states with different spring constant values. When the spring constant is 5000, the cloth doesn't drape over the whole sphere as nicely as the cloth when spring constant is 500. It took around 4 minutes for the cloth to fall off of the sphere. When the spring constant is 500, the cloth drapes over the spheres more nicely and appears more heavier. The cloth takes around 4 minutes to fall as well. When the spring constant is 50,000, the cloth appears more stiff and doesn't hug the sphere as nicely as the other two. It also falls a lot faster than the others, taking only less than 2 and a half minutes to fall off of the sphere.</p>
  </div>

  <div>
    <p>In order to handle the cloth colliding with a plane, I check to see if any of the points are within the plane. I check to see if the point crosses the plane by checking if the current position is below the plane. If the distance between the point on the plane and the point mass's position is less than 0, then the tangent point is calculated by taking the dot product of the last position and the normal vector of the plane multiplied by the normal of the plane and then subtracting this value from the last position. The correction vector is calculated by taking the difference between the tangent point and the last position. The point mass's new position is then set to the sum of the last position,  the correction scaled by the friction, and the <span>SURFACE_OFFSET</span> scaled by the normal.</p>

    <div align="middle">
      <img src="images/part3_plane.png" width="480px"/>
      <figcaption align="middle" style="font-weight: bold">Cloth resting on a plane.</figcaption>
    </div>
  </div>
</div>

<br><br>
<h2 align="middle">Part IV: Handling Self-Collisions</h2>
<div align="middle">
      <img src="images/part4_beforeCollision.png" width="480px"/>
      <figcaption align="middle" style="font-weight: bold">Cloth clipping on itself before implementing this part.</figcaption>
    </div>
<p>In order to handle the cloth colliding with itself, I implemented a hash table to map a float to a vector of <span>PointMass</span> pointers. I first implemented the function, <span>hash_position</span>, which maps a point mass's position to a float meant to represent a 3D box volume. I also implement <span>build_spatial_map</span>, which creates a hash for each point mass and checks to see if the point mass is already in the hash table. If there is no value at the hash, then I make a new vector of type <span>PointMass *</span>, add the <span>PointMass</span> to the end of the vector, and then insert the <span>hash, PointMass *</span> pair to the hash table. 
</p>
<p>I then implement <span>self_collide</span>. For the given point mass, I check to see if the point mass is in the hash table and if it is, I check to see if the point mass is the only one in the vector. If there is more than one point mass, then I loop through the vector and for each candidate point mass, I check to see if the two are within <span>2 * thickness</span> away from each other. If this distance is less than, I calculate a correction vector by the maximum distance minus the distance between the point masses and then multiplying by the direction unit vector. I take the average of the sum of all of the correction vectors and add it to the point masses position.</p>
<div align="middle">
  <table style="width=80%">
    <tr>
      <td>
        <img src="images/part4_collide1.png" width="480px"/>
      </td>
      <td>
        <img src="images/part4_collide2.png" width="480px"/>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/part4_collide3.png" width="480px"/>
      </td>
      <td>
        <img src="images/part4_collide4.png" width="480px"/>
      </td>
    </tr>
  </table>
  <img src="images/part4_collide5.png" width="480px"/>
  <div align="middle">
    <p>The images shown below are images of the cloth with different density and spring constant parameters.</p>
    <table style="width:80%">
      <tr>
        <td>
          <img src="images/part4_density1_start.png" width="480px"/>
        </td>
        <td>
          <img src="images/part4_density1_end.png" width="480px"/>
        </td>
      </tr>
    </table>
    <p align="middle" style="font-weight: bold">density = 1</p>
    <table style="width:80%">
      <tr>
        <td>
          <img src="images/part4_density200_start.png" width="480px"/>
        </td>
        <td>
          <img src="images/part4_density200_end.png" width="480px"/>
        </td>
      </tr>
    </table>
    <p align="middle" style="font-weight: bold">density = 200</p>

    <p> When the density is at 1, there are less but larger rolls and falls more evenly. It kind of reminds me of falling wrapping paper. When the density is 200, there are a lot of more folds and the cloth appears more wrinkly. </p>
  </div>

  <br><br>
  <div align="middle">
  <table style="width:80%">
      <tr>
        <td>
          <img src="images/part4_ks1_start.png" width="480px"/>
        </td>
        <td>
          <img src="images/part4_ks1_end.png" width="480px"/>
        </td>
      </tr>
    </table>
    <p align="middle" style="font-weight: bold">ks = 1</p>
    <table style="width:80%">
      <tr>
        <td>
          <img src="images/part4_ks100000_start.png" width="480px"/>
        </td>
        <td>
          <img src="images/part4_ks100000_end.png" width="480px"/>
        </td>
      </tr>
    </table>
    <p align="middle" style="font-weight: bold">ks = 100,000</p>

    <p> When the spring constant is 1, is is much more wrinkly and has more folds. It kind of looks like satin. When the spring constant is 100,000, it looks smoother and the folds are larger. It also continues to move around a lot after falling on itself.</p>
  </div>
</div>
<br><br>

<h2 align="middle">Part V: Shaders</h2>
<div>
  <p>
    A shader program is a program that allows for the execution of certain parts of the rendering pipeline. The shader can take control of settings like the hue, saturation, and brightness of an image. Vertex shaders have control over the attributes of vertices, such as transformations and color. The fragment shader will take care of the rasterization part of the pipeline and colors the pixels that are between the vertices. 
  </p>
</div>
<div>
  <p>I implemented several shaders, such as a diffuse shader. A diffuse shader will show how a diffuse object looks like under a light in the world. I implemented this by calculating the following formula: </p>

    <pre align="middle" style="font-size: 16px">L<sub>d</sub> = k<sub>d</sub> * (I / r<sup>2</sup>) * max(0, n&middot;l)</pre>

    <p>I have the diffuse coefficient set to 1.0 and I have the value <span>r</span> to the distance between the light position and the vertex position. I set the output color to the resulting vector and set the alpha value to 1.0.</p>

    <br>
    <p>I also implement a Blinn-Phong shader, which will add some specular to the object. What the shading model does is interpolate normal vectors across each triangle, resulting in fuller shading at each pixel. In order to do this, I calculate the equation: </p>

    <pre align="middle" style="font-size: 16px">L = k<sub>a</sub> * I<sub>a</sub> + k<sub>d</sub> * (I / r<sup>2</sup>) * max(0, n&middot;l) + k<sub>s</sub> * (I / r<sup>2</sup>) * max(0, n&middot;h)<sup>p</sup></pre>

    <p align="middle">For my implementation, I have these values set for my coefficients:</p>
    <pre align="middle" style="font-size: 16px">k<sub>a</sub> = 0.01</pre>
    <pre align="middle" style="font-size: 16px">I<sub>a</sub> = [0.25, 0.25, 0.25]</pre>
    <pre align="middle" style="font-size: 16px">k<sub>d</sub> = 1.0</pre>
    <pre align="middle" style="font-size: 16px">k<sub>s</sub> = 0.5</pre>
    <pre align="middle" style="font-size: 16px">p = 100.0</pre>
    <p align="middle">I set the output color to the resulting vector and set the alpha value to 1.0.</p>

    <div align="middle">
      <table style="width:80%">
      <tr>
        <td>
          <img src="images/part5_phong_ambient1.png" width="480px"/>
        </td>
        <td style="padding-left: 25px; padding-right: 40px">
          <pre align="middle" style="font-size: 16px">k<sub>a</sub> = 1.0</pre>
          <pre align="middle" style="font-size: 16px">I<sub>a</sub> = [1.0, 1.0, 1.0]</pre>
          <p align="middle"> All other coefficients are set to the value 0. The sphere and cloth appear completely white since the ambience affects the brightnness. </p>
        </td>
      </tr>
      <tr>
        <td style="padding-left: 40px; padding-right: 25px">
          <pre align="middle" style="font-size: 16px">diffuse = 5.0</pre>
          <p align="middle"> All other coefficients are set to the value 0. The light on the sphere will appear brighter the higher the diffuse value is.</p>
        </td>
        <td>
          <img src="images/part5_phong_diffuse5.png" width="480px"/>
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/part5_phong_spec1-5.png" width="480px"/>
        </td>
        <td style="padding-left: 25px; padding-right: 40px">
          <pre align="middle" style="font-size: 16px">specular = 1.5</pre>
          <p align="middle"> All other coefficients are set to the value 0. A majority of the ball is black, but the spot of light on the sphere becomes brighter the higher the specular value is.</p>
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/part5_phong_ball.png" width="480px"/>
        </td>
        <td>
          <img src="images/part5_phong_ballCloth.png" width="480px"/>
        </td>
      </tr>
    </table>
    <figcaption align="middle">The resulting spheres and cloth with Blinn-Phong shading</figcaption>
  </div>

  <br><br>
  <div align="middle">
    <p>Another shader that I implemented was a texture shader, which will map a texture onto the object. In the images shown below, I use a watercolor image for the textures of the cloth and ball.</p>
    <div align="middle">
      <table>
        <tr>
          <td>
            <img src="images/part5_texture_ball.png" width="480px"/>
          </td>
          <td>
            <img src="images/part5_texture_cloth.png" width="480px"/>
          </td>
        </tr>
      </table>
    </div>
  </div>
    
  <div>
    <p>Other features that I implemented are the bump and displacement mapping. Bump mapping will allow an object to appear as if there is more detail on it by the modification of the normal vectors of the object. To implement this, I calculated the bitangent by taking the cross-product of the model-space normal vector and the tangent vector and use the three vectors to get the tangent-bitangent-normal matrix. I then calculate the equations: </p>

    <pre align="middle" style="font-size: 16px">dU = (h(u + 1/w, v) - h(u,v)) * k<sub>h</sub> * k<sub>n</sub></pre>
    <pre align="middle" style="font-size: 16px">dV = (h(u, v + 1/h) - h(u,v)) * k<sub>h</sub> * k<sub>n</sub></pre>

    <p>where k<sub>h</sub> and k<sub>n</sub> correspond to <span>u_height_scaling</span> and <span>u_normal_scaling</span>, respectively. The local space normal is set to the vector <span>(-dU, -dV, 1)</span> and use this to get the displaced model normal, which is the TBN matrix found earlier multiplied by the local space normal.</p>

    <div align="middle">
      <img src="images/part5_bump_cloth.png" width="480px">
      <img src="images/part5_bump_sphere.png" width="480px">
    </div>

    <p>To implement displacement mapping, the fragment shader was basically the same as the shader for bump mapping. However, because the position of the vertices are being modified, I have to change things in the vertex shader. I find the new position by calculating the following: </p>
    <pre align="middle" style="font-size: 16px">p' = p + n * h(u,v) * k<sub>h</sub></pre>

    <p>I struggled for a bit on trying to get displacement mapping to work because for a while, it looked like the mess shown below.</p>
    <div align="middle">
      <img src="images/glitchyDisplacement.gif" width="480px">
    </div>
    <p align="middle">After realizing there were some errors in the first part of what the bump code was, I was able to get it to work.</p>

    <div align="middle">
      <img src="images/part5_disp_cloth.png" width="480px">
      <img src="images/part5_disp_sphere.png" width="480px">
    </div>

    <br><br>

    <div align="middle">
      <p>Below, I compare the bump mapping versus the displacement mapping with different resolutions. There is a difference in color between the resolutions and the spheres look a bit smoother when the resolution is higher.</p>

      <table style="width:80%">
        <tr>
          <td>
            <img src="images/part5_bump_sphere16.png" width="480px"/>
            <figcaption align="middle" style="font-weight: bold">bump mapping on sphere with -o 16 and -a 16</figcaption>
          </td>
          <td>
            <img src="images/part5_disp_sphere16.png" width="480px"/>
            <figcaption align="middle" style="font-weight: bold">displacement mapping on sphere with -o 16 and -a 16</figcaption>
          </td>
        </tr>
        <tr>
          <td>
            <img src="images/part5_bump_sphere128.png" width="480px"/>
            <figcaption align="middle" style="font-weight: bold">bump mapping on sphere with -o 128 and -a 128</figcaption>
          </td>
          <td>
            <img src="images/part5_disp_sphere128.png" width="480px"/>
            <figcaption align="middle" style="font-weight: bold">displacement mapping on sphere with -o 128 and -a 128</figcaption>
          </td>
        </tr>
      </table>
  </div>

  <br><br>
  <div>
    <p>I also implemented reflections by finding the <span>wi</span> vector, similar to what was done in the Ray Tracing project. To do this, I calculate the <span>wo</span> vector by multiplying the camera position vector and the vertex position  vector. Then, I multiply the dot product of <span>wo</span> and the vertex normal scaled by 2 and scale the vertex normal by this value. This is added to the negative of the <span>wo</span> vector, resulting in the <span>wi</span> vector. I use the texture function provided by glsl and sample the environment by <span>wi</span>.

    <div align="middle">
      <table>
        <tr>
          <td>
            <img src="images/part5_mirror_sphere.png" width="480px">
          </td>
          <td>
            <img src="images/part5_mirror_cloth.png" width="480px">
          </td>
        </tr>
      </table>
    </div>
  </div>
</body>
</html>
